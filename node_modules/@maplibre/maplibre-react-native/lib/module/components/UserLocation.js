"use strict";

import { forwardRef, memo, useEffect, useImperativeHandle, useRef, useState } from "react";
import Annotation from "./Annotation.js";
import CircleLayer from "./CircleLayer.js";
import HeadingIndicator from "./HeadingIndicator.js";
import NativeUserLocation from "./NativeUserLocation.js";
import locationManager from "../modules/location/locationManager.js";
import { jsx as _jsx } from "react/jsx-runtime";
const mapboxBlue = "rgba(51, 181, 229, 100)";
const layerStyles = {
  pluse: {
    circleRadius: 15,
    circleColor: mapboxBlue,
    circleOpacity: 0.2,
    circlePitchAlignment: "map"
  },
  background: {
    circleRadius: 9,
    circleColor: "#fff",
    circlePitchAlignment: "map"
  },
  foreground: {
    circleRadius: 6,
    circleColor: mapboxBlue,
    circlePitchAlignment: "map"
  }
};
export const normalIcon = (showsUserHeadingIndicator, heading) => [/*#__PURE__*/_jsx(CircleLayer, {
  id: "mapboxUserLocationPluseCircle",
  style: layerStyles.pluse
}, "mapboxUserLocationPluseCircle"), /*#__PURE__*/_jsx(CircleLayer, {
  id: "mapboxUserLocationWhiteCircle",
  style: layerStyles.background
}, "mapboxUserLocationWhiteCircle"), /*#__PURE__*/_jsx(CircleLayer, {
  id: "mapboxUserLocationBlueCicle",
  aboveLayerID: "mapboxUserLocationWhiteCircle",
  style: layerStyles.foreground
}, "mapboxUserLocationBlueCicle"), ...(showsUserHeadingIndicator && heading ? [HeadingIndicator({
  heading
})] : [])];
export let UserLocationRenderMode = /*#__PURE__*/function (UserLocationRenderMode) {
  UserLocationRenderMode["Native"] = "native";
  UserLocationRenderMode["Normal"] = "normal";
  return UserLocationRenderMode;
}({});
const UserLocation = /*#__PURE__*/memo(/*#__PURE__*/forwardRef(({
  animated = true,
  visible = true,
  showsUserHeadingIndicator = false,
  minDisplacement = 0,
  renderMode = "normal",
  androidRenderMode,
  androidPreferredFramesPerSecond,
  children,
  onUpdate,
  onPress
}, ref) => {
  const _isMounted = useRef(null);
  const locationManagerRunning = useRef(false);
  const [userLocationState, setUserLocationState] = useState({
    shouldShowUserLocation: false
  });
  useImperativeHandle(ref, () => ({
    /**
     * Whether to start or stop listening to the locationManager
     *
     * Notice, that listening will start automatically when
     * either `onUpdate` or `visible` are set
     *
     * @async
     * @param {Object} running - Object with key `running` and `boolean` value
     * @return {Promise<void>}
     */
    setLocationManager,
    /**
     *
     * If locationManager should be running
     *
     * @return {boolean}
     */
    needsLocationManagerRunning,
    _onLocationUpdate
  }));
  useEffect(() => {
    _isMounted.current = true;
    setLocationManager({
      running: needsLocationManagerRunning()
    }).then(() => {
      if (renderMode === UserLocationRenderMode.Native) {
        return;
      }
      locationManager.setMinDisplacement(minDisplacement ?? 0);
    });
    return () => {
      _isMounted.current = false;
      setLocationManager({
        running: false
      });
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
  useEffect(() => {
    locationManager.setMinDisplacement(minDisplacement ?? 0);
  }, [minDisplacement]);
  useEffect(() => {
    if (!_isMounted.current) {
      return;
    }
    setLocationManager({
      running: needsLocationManagerRunning()
    });
  });
  async function setLocationManager({
    running
  }) {
    if (locationManagerRunning.current !== running) {
      locationManagerRunning.current = running;
      if (running) {
        locationManager.addListener(_onLocationUpdate);
        const location = await locationManager.getLastKnownLocation();
        _onLocationUpdate(location);
      } else {
        locationManager.removeListener(_onLocationUpdate);
      }
    }
  }
  function needsLocationManagerRunning() {
    return !!(!!onUpdate || renderMode === UserLocationRenderMode.Normal && visible);
  }
  function _onLocationUpdate(location) {
    if (!_isMounted.current || !location) {
      return;
    }
    let coordinates;
    let heading;
    if (location && location.coords) {
      const {
        longitude,
        latitude
      } = location.coords;
      heading = location.coords.heading;
      coordinates = [longitude, latitude];
    }
    setUserLocationState({
      ...userLocationState,
      coordinates,
      heading
    });
    if (onUpdate) {
      onUpdate(location);
    }
  }
  if (!visible) {
    return null;
  }
  if (renderMode === UserLocationRenderMode.Native) {
    const props = {
      androidRenderMode,
      iosShowsUserHeadingIndicator: showsUserHeadingIndicator,
      androidPreferredFramesPerSecond
    };
    return /*#__PURE__*/_jsx(NativeUserLocation, {
      ...props
    });
  }
  if (!userLocationState.coordinates) {
    return null;
  }
  return /*#__PURE__*/_jsx(Annotation, {
    animated: animated,
    id: "mapboxUserLocation",
    onPress: onPress,
    coordinates: userLocationState.coordinates,
    style: {
      iconRotate: userLocationState.heading
    },
    children: children || normalIcon(showsUserHeadingIndicator, userLocationState.heading)
  });
}));
export default UserLocation;
//# sourceMappingURL=UserLocation.js.map