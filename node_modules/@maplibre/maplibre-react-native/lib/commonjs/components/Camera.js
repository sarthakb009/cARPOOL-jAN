"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.UserTrackingMode = exports.NATIVE_MODULE_NAME = void 0;
exports.getNativeCameraMode = getNativeCameraMode;
var _helpers = require("@turf/helpers");
var _react = require("react");
var _reactNative = require("react-native");
var _MLNModule = require("../MLNModule.js");
var _useNativeRef = require("../hooks/useNativeRef.js");
var _makeNativeBounds = require("../utils/makeNativeBounds.js");
var _jsxRuntime = require("react/jsx-runtime");
const NATIVE_MODULE_NAME = exports.NATIVE_MODULE_NAME = "RCTMLNCamera";
let UserTrackingMode = exports.UserTrackingMode = /*#__PURE__*/function (UserTrackingMode) {
  UserTrackingMode["Follow"] = "normal";
  UserTrackingMode["FollowWithHeading"] = "compass";
  UserTrackingMode["FollowWithCourse"] = "course";
  return UserTrackingMode;
}({});
function getNativeCameraMode(mode) {
  switch (mode) {
    case "flyTo":
      return _MLNModule.CameraModes.Flight;
    case "moveTo":
      return _MLNModule.CameraModes.None;
    case "linearTo":
      return _MLNModule.CameraModes.Linear;
    case "easeTo":
      return _MLNModule.CameraModes.Ease;
    default:
      return _MLNModule.CameraModes.None;
  }
}
function makeNativeCameraStop(stop) {
  if (!stop) {
    return undefined;
  }
  const nativeStop = {};
  if (stop.animationDuration !== undefined) {
    nativeStop.duration = stop.animationDuration;
  }
  if (stop.animationMode !== undefined) {
    nativeStop.mode = getNativeCameraMode(stop.animationMode);
  }
  if (stop.centerCoordinate) {
    nativeStop.centerCoordinate = JSON.stringify((0, _helpers.point)(stop.centerCoordinate));
  }
  if (stop.heading !== undefined) {
    nativeStop.heading = stop.heading;
  }
  if (stop.pitch !== undefined) {
    nativeStop.pitch = stop.pitch;
  }
  if (stop.zoomLevel !== undefined) {
    nativeStop.zoom = stop.zoomLevel;
  }
  if (stop.bounds && stop.bounds.ne && stop.bounds.sw) {
    const {
      ne,
      sw
    } = stop.bounds;
    nativeStop.bounds = (0, _makeNativeBounds.makeNativeBounds)(ne, sw);
  }
  const paddingTop = stop.padding?.paddingTop ?? stop.bounds?.paddingTop;
  if (paddingTop !== undefined) {
    nativeStop.paddingTop = paddingTop;
  }
  const paddingRight = stop.padding?.paddingRight ?? stop.bounds?.paddingRight;
  if (paddingRight !== undefined) {
    nativeStop.paddingRight = paddingRight;
  }
  const paddingBottom = stop.padding?.paddingBottom ?? stop.bounds?.paddingBottom;
  if (paddingBottom !== undefined) {
    nativeStop.paddingBottom = paddingBottom;
  }
  const paddingLeft = stop.padding?.paddingLeft ?? stop.bounds?.paddingLeft;
  if (paddingLeft !== undefined) {
    nativeStop.paddingLeft = paddingLeft;
  }
  return nativeStop;
}
const Camera = /*#__PURE__*/(0, _react.memo)(/*#__PURE__*/(0, _react.forwardRef)(({
  animationMode,
  animationDuration,
  bounds,
  centerCoordinate,
  defaultSettings,
  followUserLocation,
  followHeading,
  followPitch,
  followUserMode,
  followZoomLevel,
  heading,
  maxBounds,
  maxZoomLevel,
  minZoomLevel,
  onUserTrackingModeChange,
  padding,
  pitch,
  zoomLevel
}, ref) => {
  const nativeCamera = (0, _useNativeRef.useNativeRef)();
  const nativeStop = (0, _react.useMemo)(() => {
    return makeNativeCameraStop({
      animationDuration,
      animationMode,
      bounds,
      centerCoordinate,
      heading,
      padding,
      pitch,
      zoomLevel
    });
  }, [animationDuration, animationMode, bounds, centerCoordinate, heading, padding, pitch, zoomLevel]);
  const nativeDefaultStop = (0, _react.useMemo)(() => {
    return makeNativeCameraStop(defaultSettings);
  }, [defaultSettings]);
  const nativeMaxBounds = (0, _react.useMemo)(() => {
    if (!maxBounds?.ne || !maxBounds?.sw) {
      return undefined;
    }
    return (0, _makeNativeBounds.makeNativeBounds)(maxBounds.ne, maxBounds.sw);
  }, [maxBounds]);
  const setCamera = (config = {}) => {
    if ("stops" in config) {
      nativeCamera.current?.setNativeProps({
        stop: {
          stops: config.stops.map(stopItem => makeNativeCameraStop(stopItem)).filter(stopItem => !!stopItem)
        }
      });
    } else {
      const nativeStop = makeNativeCameraStop(config);
      if (nativeStop) {
        nativeCamera.current?.setNativeProps({
          stop: nativeStop
        });
      }
    }
  };
  const fitBounds = (ne, sw, padding, animationDuration) => {
    const _padding = {};
    if (Array.isArray(padding)) {
      if (padding.length === 2) {
        _padding.paddingTop = padding[0];
        _padding.paddingBottom = padding[0];
        _padding.paddingLeft = padding[1];
        _padding.paddingRight = padding[1];
      } else if (padding.length === 4) {
        _padding.paddingTop = padding[0];
        _padding.paddingRight = padding[1];
        _padding.paddingBottom = padding[2];
        _padding.paddingLeft = padding[3];
      }
    } else if (typeof padding === "number") {
      _padding.paddingLeft = padding;
      _padding.paddingRight = padding;
      _padding.paddingTop = padding;
      _padding.paddingBottom = padding;
    }
    setCamera({
      bounds: {
        ne,
        sw
      },
      padding: _padding,
      animationDuration,
      animationMode: "easeTo"
    });
  };
  const flyTo = (coordinates, animationDuration = 2000) => {
    setCamera({
      centerCoordinate: coordinates,
      animationDuration,
      animationMode: "flyTo"
    });
  };
  const moveTo = (coordinates, animationDuration = 0) => {
    setCamera({
      centerCoordinate: coordinates,
      animationDuration,
      animationMode: "easeTo"
    });
  };
  const zoomTo = (zoomLevel, animationDuration = 2000) => {
    setCamera({
      zoomLevel,
      animationDuration,
      animationMode: "flyTo"
    });
  };
  (0, _react.useImperativeHandle)(ref, () => ({
    /**
     * Map camera transitions to fit provided bounds
     *
     * @example
     * cameraRef.current?.fitBounds([lng, lat], [lng, lat])
     * cameraRef.current?.fitBounds([lng, lat], [lng, lat], 20, 1000) // padding for all sides
     * cameraRef.current?.fitBounds([lng, lat], [lng, lat], [verticalPadding, horizontalPadding], 1000)
     * cameraRef.current?.fitBounds([lng, lat], [lng, lat], [top, right, bottom, left], 1000)
     *
     * @param {Array<Number>} ne - North east coordinate of bound
     * @param {Array<Number>} sw - South west coordinate of bound
     * @param {Number|Array<Number>|undefined} padding - Padding for the bounds
     * @param {Number=} animationDuration - Duration of camera animation
     * @return {void}
     */
    fitBounds,
    /**
     * Map camera will fly to new coordinate
     *
     * @example
     * cameraRef.current?.flyTo([lng, lat])
     * cameraRef.current?.flyTo([lng, lat], 12000)
     *
     *  @param {Array<Number>} coordinates - Coordinates that map camera will jump to
     *  @param {Number=} animationDuration - Duration of camera animation
     *  @return {void}
     */
    flyTo,
    /**
     * Map camera will move to new coordinate at the same zoom level
     *
     * @example
     * cameraRef.current?.moveTo([lng, lat], 200) // eases camera to new location based on duration
     * cameraRef.current?.moveTo([lng, lat]) // snaps camera to new location without any easing
     *
     *  @param {Array<Number>} coordinates - Coordinates that map camera will move too
     *  @param {Number=} animationDuration - Duration of camera animation
     *  @return {void}
     */
    moveTo,
    /**
     * Map camera will zoom to specified level
     *
     * @example
     * cameraRef.current?.zoomTo(16)
     * cameraRef.current?.zoomTo(16, 100)
     *
     * @param {Number} zoomLevel - Zoom level that the map camera will animate too
     * @param {Number=} animationDuration - Duration of camera animation
     * @return {void}
     */
    zoomTo,
    /**
     * Map camera will perform updates based on provided config. Advanced use only!
     *
     * @example
     * cameraRef.current?.setCamera({
     *   centerCoordinate: [lng, lat],
     *   zoomLevel: 16,
     *   animationDuration: 2000,
     * })
     *
     * cameraRef.current?.setCamera({
     *   stops: [
     *     { pitch: 45, animationDuration: 200 },
     *     { heading: 180, animationDuration: 300 },
     *   ]
     * })
     *
     *  @param {Object} config - Camera configuration
     */
    setCamera
  }));
  return /*#__PURE__*/(0, _jsxRuntime.jsx)(RCTMLNCamera, {
    testID: "Camera",
    ref: nativeCamera,
    stop: nativeStop,
    defaultStop: nativeDefaultStop,
    maxBounds: nativeMaxBounds,
    followUserLocation: followUserLocation,
    followHeading: followHeading,
    followPitch: followPitch,
    followUserMode: followUserMode,
    followZoomLevel: followZoomLevel,
    maxZoomLevel: maxZoomLevel,
    minZoomLevel: minZoomLevel,
    onUserTrackingModeChange: onUserTrackingModeChange
  });
}));
const RCTMLNCamera = (0, _reactNative.requireNativeComponent)(NATIVE_MODULE_NAME);
var _default = exports.default = Camera;
//# sourceMappingURL=Camera.js.map