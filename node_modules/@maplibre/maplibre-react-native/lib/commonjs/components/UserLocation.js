"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.normalIcon = exports.default = exports.UserLocationRenderMode = void 0;
var _react = require("react");
var _Annotation = _interopRequireDefault(require("./Annotation.js"));
var _CircleLayer = _interopRequireDefault(require("./CircleLayer.js"));
var _HeadingIndicator = _interopRequireDefault(require("./HeadingIndicator.js"));
var _NativeUserLocation = _interopRequireDefault(require("./NativeUserLocation.js"));
var _locationManager = _interopRequireDefault(require("../modules/location/locationManager.js"));
var _jsxRuntime = require("react/jsx-runtime");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const mapboxBlue = "rgba(51, 181, 229, 100)";
const layerStyles = {
  pluse: {
    circleRadius: 15,
    circleColor: mapboxBlue,
    circleOpacity: 0.2,
    circlePitchAlignment: "map"
  },
  background: {
    circleRadius: 9,
    circleColor: "#fff",
    circlePitchAlignment: "map"
  },
  foreground: {
    circleRadius: 6,
    circleColor: mapboxBlue,
    circlePitchAlignment: "map"
  }
};
const normalIcon = (showsUserHeadingIndicator, heading) => [/*#__PURE__*/(0, _jsxRuntime.jsx)(_CircleLayer.default, {
  id: "mapboxUserLocationPluseCircle",
  style: layerStyles.pluse
}, "mapboxUserLocationPluseCircle"), /*#__PURE__*/(0, _jsxRuntime.jsx)(_CircleLayer.default, {
  id: "mapboxUserLocationWhiteCircle",
  style: layerStyles.background
}, "mapboxUserLocationWhiteCircle"), /*#__PURE__*/(0, _jsxRuntime.jsx)(_CircleLayer.default, {
  id: "mapboxUserLocationBlueCicle",
  aboveLayerID: "mapboxUserLocationWhiteCircle",
  style: layerStyles.foreground
}, "mapboxUserLocationBlueCicle"), ...(showsUserHeadingIndicator && heading ? [(0, _HeadingIndicator.default)({
  heading
})] : [])];
exports.normalIcon = normalIcon;
let UserLocationRenderMode = exports.UserLocationRenderMode = /*#__PURE__*/function (UserLocationRenderMode) {
  UserLocationRenderMode["Native"] = "native";
  UserLocationRenderMode["Normal"] = "normal";
  return UserLocationRenderMode;
}({});
const UserLocation = /*#__PURE__*/(0, _react.memo)(/*#__PURE__*/(0, _react.forwardRef)(({
  animated = true,
  visible = true,
  showsUserHeadingIndicator = false,
  minDisplacement = 0,
  renderMode = "normal",
  androidRenderMode,
  androidPreferredFramesPerSecond,
  children,
  onUpdate,
  onPress
}, ref) => {
  const _isMounted = (0, _react.useRef)(null);
  const locationManagerRunning = (0, _react.useRef)(false);
  const [userLocationState, setUserLocationState] = (0, _react.useState)({
    shouldShowUserLocation: false
  });
  (0, _react.useImperativeHandle)(ref, () => ({
    /**
     * Whether to start or stop listening to the locationManager
     *
     * Notice, that listening will start automatically when
     * either `onUpdate` or `visible` are set
     *
     * @async
     * @param {Object} running - Object with key `running` and `boolean` value
     * @return {Promise<void>}
     */
    setLocationManager,
    /**
     *
     * If locationManager should be running
     *
     * @return {boolean}
     */
    needsLocationManagerRunning,
    _onLocationUpdate
  }));
  (0, _react.useEffect)(() => {
    _isMounted.current = true;
    setLocationManager({
      running: needsLocationManagerRunning()
    }).then(() => {
      if (renderMode === UserLocationRenderMode.Native) {
        return;
      }
      _locationManager.default.setMinDisplacement(minDisplacement ?? 0);
    });
    return () => {
      _isMounted.current = false;
      setLocationManager({
        running: false
      });
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
  (0, _react.useEffect)(() => {
    _locationManager.default.setMinDisplacement(minDisplacement ?? 0);
  }, [minDisplacement]);
  (0, _react.useEffect)(() => {
    if (!_isMounted.current) {
      return;
    }
    setLocationManager({
      running: needsLocationManagerRunning()
    });
  });
  async function setLocationManager({
    running
  }) {
    if (locationManagerRunning.current !== running) {
      locationManagerRunning.current = running;
      if (running) {
        _locationManager.default.addListener(_onLocationUpdate);
        const location = await _locationManager.default.getLastKnownLocation();
        _onLocationUpdate(location);
      } else {
        _locationManager.default.removeListener(_onLocationUpdate);
      }
    }
  }
  function needsLocationManagerRunning() {
    return !!(!!onUpdate || renderMode === UserLocationRenderMode.Normal && visible);
  }
  function _onLocationUpdate(location) {
    if (!_isMounted.current || !location) {
      return;
    }
    let coordinates;
    let heading;
    if (location && location.coords) {
      const {
        longitude,
        latitude
      } = location.coords;
      heading = location.coords.heading;
      coordinates = [longitude, latitude];
    }
    setUserLocationState({
      ...userLocationState,
      coordinates,
      heading
    });
    if (onUpdate) {
      onUpdate(location);
    }
  }
  if (!visible) {
    return null;
  }
  if (renderMode === UserLocationRenderMode.Native) {
    const props = {
      androidRenderMode,
      iosShowsUserHeadingIndicator: showsUserHeadingIndicator,
      androidPreferredFramesPerSecond
    };
    return /*#__PURE__*/(0, _jsxRuntime.jsx)(_NativeUserLocation.default, {
      ...props
    });
  }
  if (!userLocationState.coordinates) {
    return null;
  }
  return /*#__PURE__*/(0, _jsxRuntime.jsx)(_Annotation.default, {
    animated: animated,
    id: "mapboxUserLocation",
    onPress: onPress,
    coordinates: userLocationState.coordinates,
    style: {
      iconRotate: userLocationState.heading
    },
    children: children || normalIcon(showsUserHeadingIndicator, userLocationState.heading)
  });
}));
var _default = exports.default = UserLocation;
//# sourceMappingURL=UserLocation.js.map